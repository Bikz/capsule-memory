# Capsule Memory

Capsule Memory is an AI agent memory substrate—a "router as a service" that lets any agent store long-term memories, retrieve contextual knowledge, pin important facts, and manage retention policies. The goal is to provide a transparent, policy-driven memory layer powered by semantic search so agents can reason over meaning rather than keyword matches.

## Project Snapshot
- **Language & Framework:** TypeScript with [Modelence](https://modelence.com/) (backend + React/Vite frontend)
- **Database:** MongoDB Atlas with Vector Search
- **Embeddings:** Voyage AI (`voyage-3.5`) for 1024-dimension vectors
- **Optional Extensions:** Reranking with Voyage AI, LLM summaries via OpenAI/Fireworks, Modelence Cloud deployment

## Core Capabilities
1. **Store Memory**
   - Persist content, embedding, timestamp, and optional metadata.
   - Support pinning on insert and apply basic validation.
2. **Semantic Retrieval**
   - Embed queries (`inputType: 'query'`) and perform MongoDB vector search.
   - Optionally rerank results for improved relevance.
   - Return relevance scores and explanations for transparency.
3. **Pin / Unpin Memory**
   - Toggle `pinned` flag to shield critical items from policy-based deletion.
4. **Forget Memory**
   - Explicit deletion flow with optional explanation/logging.
5. **Retention Policies**
   - Enforce a configurable memory ceiling (e.g., 100 items).
   - Auto-remove oldest unpinned entry when limit is exceeded.
   - Generate explanations for auto-forget actions.
6. **Planned Stretch**
   - Summarize aging memories via external LLM before deletion.
   - Introduce richer metadata, tags, and multi-tenant isolation as needed.

## Architecture Draft
```
capsule-memory/
├── src/
│   ├── client/               # React/Vite frontend (Modelence scaffold)
│   │   └── MemoryPage.tsx    # Memory management UI
│   └── server/
│       ├── memory/
│       │   ├── db.ts         # Store definition + indexes
│       │   ├── voyage.ts     # Voyage embedding + rerank helpers
│       │   └── index.ts      # Module with queries + mutations
│       └── app.ts            # startApp with memory module registration
├── docs/
│   └── implementation-plan.md (optional extended notes)
├── public/                   # Static assets (from Modelence template)
├── package.json
├── tsconfig.json
├── vite.config.ts
└── README.md
```

> The actual directory tree will be generated by the Modelence CLI scaffold (see below). The structure above highlights key files to implement once the scaffold exists.

## Getting Started
1. **Install prerequisites**
   - Node.js 18+
   - npm 9+ (or pnpm/yarn if preferred)
   - MongoDB Atlas cluster + connection string
   - Voyage AI API key (hackathon token is fine)

2. **Bootstrap the project**
   ```bash
   npx create-modelence-app@latest capsule-memory
   # or in-place if already inside repo
   npx create-modelence-app@latest .
   ```
   - Use `--template voyage-ai` for a head start on embedding utilities.
   - Commit the generated scaffold before layering in feature work.

3. **Configure environment**
   - Add MongoDB URI and Voyage key to `.env` or `.modelence.env`.
     ```
     MONGO_URL="your-atlas-connection-string"
     VOYAGE_API_KEY="your-voyage-key"
     ```
   - If using Modelence Cloud, run `npx modelence setup --token <env_token>` and follow prompts.

4. **Install dependencies & run**
   ```bash
   npm install
   npm run dev
   ```
   - Visit `http://localhost:5173/memory` (exact port depends on Vite) to access the UI once implemented.
   - Backend and frontend run together via Modelence dev server.

5. **Recommended tooling**
   - Configure ESLint + Prettier (Modelence template has defaults).
   - Consider enabling typecheck on commit (`npm run typecheck`).

## Implementation Notes
- **Store Definition (`src/server/memory/db.ts`):**
  - Use `schema.embedding()` for the `embedding` field.
  - Register a vector index via `Store.vectorIndex` with `dimensions: 1024`.
  - Add a descending index on `createdAt` for quick recency queries.

- **Voyage Helpers (`voyage.ts`):**
  - Lazily instantiate `VoyageAIClient` using env/config for API key.
  - Expose `generateEmbedding(text, inputType)` and optional `rerankResults`.
  - Ensure informative errors when keys are missing.

- **Module (`index.ts`):**
  - Register store and define queries (`getMemories`, `searchMemory`).
  - Implement mutations (`addMemory`, `pinMemory`, `deleteMemory`).
  - Enforce memory limit inside `addMemory`, skipping pinned items.
  - Return explanatory messages with each response to aid agent behaviors.

- **Frontend (`MemoryPage.tsx`):**
  - Use `@modelence/react-query` helpers for data fetching.
  - Provide forms for adding memories, pin toggles, deletion, and search.
  - Display policy messages and search explanations inline.

## Development Checklist
- [ ] Scaffold Modelence project (Voyage template recommended).
- [ ] Wire up MongoDB connection + env variables.
- [ ] Implement memory store, helpers, and module endpoints.
- [ ] Build MemoryPage UI with add/search/pin/delete flows.
- [ ] Verify vector index creation in MongoDB Atlas.
- [ ] Add basic tests (unit/integration) or manual verification steps.
- [ ] Document available queries/mutations for agent integration.

## Next Steps for Coding Agent
1. Generate scaffold via Modelence CLI and commit baseline.
2. Implement backend module pieces following `Implementation Notes`.
3. Build out MemoryPage UI; ensure React Query cache invalidation.
4. Add logging for policy actions (optional: central logger).
5. Stretch: integrate summaries or richer metadata once core flow is stable.

---

Questions or ideas? Capture them in `docs/` or GitHub issues so the next agent can iterate quickly. Happy building!
